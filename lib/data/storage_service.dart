// lib/data/storage_service.dart

import 'package:hive_flutter/hive_flutter.dart';
import 'package:intl/intl.dart'; // Required for date formatting
import '../models/emission_data.dart';

class StorageService {
  static const String _boxName = 'dailyEmissionBox';
  static const String _entryBoxName = 'emissionEntryBox'; // New box for raw entries
  late Box<DailyEmission> _emissionBox;
  late Box<EmissionEntry> _entryBox; // New box

  // Helper function to format DateTime to a consistent key (YYYY-MM-DD)
  String _formatDate(DateTime date) {
    return DateFormat('yyyy-MM-dd').format(date);
  }

  Future<void> init() async {
    // You must register the adapters generated by Hive
    // Hive.registerAdapter(EmissionEntryAdapter()); // Assuming you would generate this
    // Hive.registerAdapter(DailyEmissionAdapter()); // Assuming you would generate this
    await Hive.initFlutter();

    // Boxes for individual entries and daily summaries
    // NOTE: The compiler expects EmissionEntry to be defined for the box.
    _entryBox = await Hive.openBox<EmissionEntry>(_entryBoxName);
    _emissionBox = await Hive.openBox<DailyEmission>(_boxName);
  }

  // --- EmissionEntry CRUD (for individual logging) ---

  // NOTE: This logic needs to be simplified to use the existing `_entryBox`
  // as the previous logic assumed the new model structure was complete.
  
  // Save a single raw emission entry
  Future<void> saveEntry(EmissionEntry entry) async {
    // Use the Hive generated key as the ID for now
    final key = await _entryBox.add(entry);
    // You would typically update the entry with the generated ID, but we skip this for simplicity
    
    // After saving a raw entry, recalculate the daily summary and save it
    await _updateDailySummary(entry.date);
  }
  
  // Get all entries for a specific date
  Future<List<EmissionEntry>> getEntriesForDate(DateTime date) async {
    final dateKey = _formatDate(date);
    // Filter all entries by dateKey (assuming the date is part of the entry)
    final targetEntries = _entryBox.values.where((e) => _formatDate(e.date) == dateKey).toList();
    return targetEntries;
  }
  
  // Helper to re-calculate and save the daily summary after a new entry is added
  Future<void> _updateDailySummary(DateTime date) async {
    final dateKey = _formatDate(date);
    final entriesForDay = await getEntriesForDate(date);
    
    // Calculate the total emission by summing the emission values of all entries
    final totalEmission = entriesForDay.fold(0.0, (sum, entry) => sum + entry.emissionValue);
    
    // Create the DailyEmission object with the updated entries
    final updatedDaily = DailyEmission(
      date: dateKey,
      entries: entriesForDay, // Pass the list of entries
    );

    await _emissionBox.put(dateKey, updatedDaily);
  }

  // Retrieve past 7 days for chart visualization (used by InsightsScreen)
  List<DailyEmission> getWeeklyEmissions() {
    final List<DailyEmission> emissions = [];
    final now = DateTime.now();

    for (int i = 6; i >= 0; i--) {
      final date = now.subtract(Duration(days: i));
      final dateKey = _formatDate(date);
      
      final data = _emissionBox.get(dateKey);
      if (data != null) {
        emissions.add(data);
      } else {
        // Add placeholder for days with no data
        emissions.add(DailyEmission(
          date: dateKey,
          entries: [], // Must pass an empty list of entries
        ));
      }
    }
    return emissions;
  }
  
  // NOTE: Removed `saveDailyEmission` and `getDailyEmission` as they are now handled 
  // by `_updateDailySummary` and `getWeeklyEmissions` respectively for the summary data.
  // The logic is now centralized around saving individual entries and updating the summary.
}
